<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>简单工厂模式详解</title>
    <url>/2020/07/10/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>  简单工厂模式（Simple Factory Pattern）是指由一个工厂对象决定创建出哪一种产品类 的实例。属于创建型模式，但它不属于 GOF，23 种设计模式。</p>
<a id="more"></a>

<h4 id="二、适用场景"><a href="#二、适用场景" class="headerlink" title="二、适用场景"></a>二、适用场景</h4><p>1、适用 于工厂类负责创建的对象较少的场景，</p>
<p>2、且客户端只需要传入工厂类的参数，对于如何创 建对象的逻辑不需要关心。</p>
<h4 id="三、作用"><a href="#三、作用" class="headerlink" title="三、作用"></a>三、作用</h4><p>根据不同的情景（参数）创建不同的对象。</p>
<h4 id="四、缺点"><a href="#四、缺点" class="headerlink" title="四、缺点"></a>四、缺点</h4><p>1、工厂类的职业相对过重，增加新的产品时需要修改工厂类的判断逻辑，违背开闭原则。</p>
<p>2、不易于扩展过于复杂的产品结构。</p>
<h4 id="五、代码实现（示例）"><a href="#五、代码实现（示例）" class="headerlink" title="五、代码实现（示例）"></a>五、代码实现（示例）</h4><p>1、示例背景：一个时间管理者拥有多个女朋友，那么他要记住每个女朋友的名字，每天晚上根据名字去微信找到她们，给她们每个人发晚安，或者叫她们来侍寝。</p>
<p>2、创建每个对象需要做的事</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CreateObject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createObject</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3、首先创建两个女朋友</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReBa</span> <span class="keyword">implements</span> <span class="title">CreateObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是迪丽热巴，我来啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NaZha</span> <span class="keyword">implements</span> <span class="title">CreateObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是古力娜扎，我来啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>4、创建一个工厂（相当于微信，通过微信管理她们）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirlFriendFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">CreateObject <span class="title">createGirlFriendWay1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"迪丽热巴"</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReBa();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"古力娜扎"</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NaZha();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">CreateObject <span class="title">createGirlFriendWay2</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CreateObject) clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>5、写个测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        GirlFriendFactory girlFriendFactory = <span class="keyword">new</span> GirlFriendFactory();</span><br><span class="line">        CreateObject reBa = girlFriendFactory.createGirlFriendWay1(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        reBa.createObject();</span><br><span class="line"></span><br><span class="line">        CreateObject naZha = girlFriendFactory.createGirlFriendWay2(NaZha<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        naZha.createObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>6、测试结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是迪丽热巴，我来啦</span><br><span class="line">我是古力娜扎，我来啦</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工作</category>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理模式详解</title>
    <url>/2020/07/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="一、动态代理的好处"><a href="#一、动态代理的好处" class="headerlink" title="一、动态代理的好处"></a>一、动态代理的好处</h4><p>  动态代理：其实动态代理与静态代理的本质一样，最终程序运行时都需要生成一个代理对象实例，通过它来完成相关增强以及业务逻辑，只不过静态代理需要硬编码的方式指定，而动态代理则是以动态方式生成代理(有编译时操作字节码生成的方式、以及运行时通过反射、字节码生成的方式)。动态生成的好处很明显，代理逻辑与业务逻辑是互相独立的，没有耦合，代理1个类100个类没有任何区别。</p>
<a id="more"></a>

<h4 id="二、动态代理例子（便于理解）"><a href="#二、动态代理例子（便于理解）" class="headerlink" title="二、动态代理例子（便于理解）"></a>二、动态代理例子（便于理解）</h4><p>  到了饭点了，有两个用户都需要买菜，小姜要买青菜，小鑫要买萝卜，他们下单，骑手接收到订单之后去到超时给他们买菜，并送给他们。其中：小姜、小鑫就是被代理对象，骑手就是代理对象，买菜就是代理的内容或者动作。</p>
<h4 id="三、实现代码："><a href="#三、实现代码：" class="headerlink" title="三、实现代码："></a>三、实现代码：</h4><p>1、首先创建一个代理的动作或者内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要代理的内容或动作，如需要跑腿买东西</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shop</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、创建两个需要买菜的用户（被代理对象）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被代理对象小姜</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jiang</span> <span class="keyword">implements</span> <span class="title">Shop</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小姜下单买青菜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被代理对象小鑫</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xin</span> <span class="keyword">implements</span> <span class="title">Shop</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小鑫下单买萝卜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3、创建一个骑手（创建代理对象）,他会根据被代理对象的不同，买不同的菜：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpressMan</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    ExpressMan(Object object) &#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"骑手接到订单"</span>);</span><br><span class="line">        <span class="comment">//通过反射根据传入的被代理对象，匹配相应的方法（代理内容或动作）</span></span><br><span class="line">        Object invoke = method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">"送达"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>4、写一个测试类，开始下单买菜：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      User user = <span class="keyword">new</span> User();</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 参数1：通过对象引用获取类加载器</span></span><br><span class="line"><span class="comment">       * 参数2：通过对象引用反射获取对象所有接口</span></span><br><span class="line"><span class="comment">       * 参数3：代理对象（被代理的对象）</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      Shop shop = (Shop)Proxy.newProxyInstance(user.getClass().getClassLoader(), user.getClass().getInterfaces(), <span class="keyword">new</span> ExpressMan(user));</span><br><span class="line">      shop.shop();</span><br><span class="line"></span><br><span class="line">      User2 user2 = <span class="keyword">new</span> User2();</span><br><span class="line">      Shop shop2 = (Shop)Proxy.newProxyInstance(user.getClass().getClassLoader(), user.getClass().getInterfaces(), <span class="keyword">new</span> ExpressMan(user2));</span><br><span class="line">      shop2.shop();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>5、运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">骑手接到订单</span><br><span class="line">小姜下单买青菜</span><br><span class="line">送达</span><br><span class="line"></span><br><span class="line">骑手接到订单</span><br><span class="line">小鑫下单买萝卜</span><br><span class="line">送达</span><br></pre></td></tr></table></figure>



<p>四、使用场景</p>
<p>  1、设计模式中有一个设计原则是开闭原则，是说对修改关闭对扩展开放，我们在工作中有时会接手很多前人的代码，里面代码逻辑让人摸不着头脑(sometimes the code is really like shit)，这时就很难去下手修改代码，那么这时我们就可以通过代理对类进行增强。</p>
<p>  2、我们在使用RPC框架的时候，框架本身并不能提前知道各个业务方要调用哪些接口的哪些方法 。那么这个时候，就可用通过动态代理的方式来建立一个中间人给客户端使用，也方便框架进行搭建逻辑，某种程度上也是客户端代码和框架松耦合的一种表现。</p>
<p>  3、Spring的AOP机制就是采用动态代理的机制来实现切面编程。</p>
]]></content>
      <categories>
        <category>工作</category>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云K8S托管版配置及部署</title>
    <url>/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>kubernetes官方文档：<a href="https://kubernetes.io/docs/home/" target="_blank" rel="noopener">https://kubernetes.io/docs/home/</a><br>kubernates中文文档：<a href="http://docs.kubernetes.org.cn/" target="_blank" rel="noopener">http://docs.kubernetes.org.cn/</a><br>阿里云容器服务k8s版文档：<a href="https://help.aliyun.com/product/85222.html?spm=a2c4g.11186623.6.540.6c874c078ZtIcw" target="_blank" rel="noopener">https://help.aliyun.com/product/85222.html?spm=a2c4g.11186623.6.540.6c874c078ZtIcw</a></p>
<a id="more"></a>

<h2 id="创建k8s托管版"><a href="#创建k8s托管版" class="headerlink" title="创建k8s托管版"></a>创建k8s托管版</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul>
<li>开通容器服务Kubernetes</li>
<li>登录RAM管理控制台开通相应服务(授权)</li>
<li>开通弹性伸缩服务</li>
<li>同一地域中2台以上阿里云ECS</li>
<li>创建专有网络</li>
<li>创建虚拟交换机</li>
<li>账户余额≥100元</li>
</ul>
<h3 id="创建入口"><a href="#创建入口" class="headerlink" title="创建入口"></a>创建入口</h3><p>进入服务容器服务控制台<br><a href="https://cs.console.aliyun.com/?#/k8s/cluster/list" target="_blank" rel="noopener">https://cs.console.aliyun.com/?#/k8s/cluster/list</a></p>
<p><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/image-20200707164853341-1594216816201.png" alt="image-20200707164853341"></p>
<p>集群列表页中点击注册集群 ，进入创建页面</p>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><ul>
<li>创建类型为Kubernetes托管版</li>
<li>kubernetes及容器选择 k8s 选 1.16.9-aliyun.1(目前较高版本) 容器选择docker</li>
<li>需要创建专有网络和虚拟交换机</li>
<li>网络插件选择Terway 并选择Pod 虚拟交换机</li>
<li>service CIDR 网段，Pod的ip因为数量、伸缩等客观因素，需要有service进行ip:port映射并对外暴露，需要单独配置，如果需要创建多个集群 需要规划一下网段</li>
</ul>
<p><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594087794015-d7bca4f2-2143-4765-bcd6-05d11b5cc569.png" alt="image.png"><br><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594088414674-bf500118-e140-426c-b4ff-36447e25de24.png" alt="image.png"></p>
<h3 id="worker配置"><a href="#worker配置" class="headerlink" title="worker配置"></a>worker配置</h3><ul>
<li>添加节点实例 实例创建需要考虑Terway兼容性 即可支持Pod数量  查看方法可选择新增实例中实例列表查看可支持pod数量</li>
</ul>
<p><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594089704812-b27c6b76-3a53-4529-ac94-1f1310429cf4.png" alt="image.png"></p>
<p><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594091618803-d61484f0-2e63-4519-9487-1a4d5bf5617c.png" alt="image.png"></p>
<h3 id="组件配置"><a href="#组件配置" class="headerlink" title="组件配置"></a>组件配置</h3><ul>
<li>ingress插件 建议公网，后续服务可通过ingress 进行映射</li>
<li>日志服务 建议选择已有project  <a href="https://sls.console.aliyun.com/lognext/profile" target="_blank" rel="noopener">创建project</a></li>
</ul>
<p><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594093603109-1aa5e4b9-962f-4f3e-92d2-26c2fcc6799d.png" alt="image.png"></p>
<h2 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h2><h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><p>采用镜像-分批发布方式发布<br>发布流程 创建阿里云镜像 –&gt;创建分批发布–&gt; 第一次发布–&gt; 发布回滚/发布完成</p>
<h3 id="创建阿里云镜像"><a href="#创建阿里云镜像" class="headerlink" title="创建阿里云镜像"></a>创建阿里云镜像</h3><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/repositories" target="_blank" rel="noopener">阿里云镜像服务控制台</a></p>
<ul>
<li>创建命名空间</li>
</ul>
<p><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594094666837-e67d4857-80ff-400c-8642-d6b4a8fc8836.png" alt="image.png"></p>
<ul>
<li>创建镜像仓库<ul>
<li>选择本地仓库，使用命令推送镜像到镜像仓库</li>
<li>点击对应仓库名称，仓库详情中有操作指南可以参考</li>
</ul>
</li>
</ul>
<p><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594094837178-7acbcd17-43eb-4d33-931d-9ead74e9bc8a.png" alt="image.png"></p>
<p><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594094913726-af8b687a-4944-41bd-ae07-0923240118f2.png" alt="image.png"><br><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594095031809-a664ecee-191d-4f46-b809-7b86cd831d4a.png" alt="image.png"></p>
<h3 id="创建分批发布"><a href="#创建分批发布" class="headerlink" title="创建分批发布"></a>创建分批发布</h3><ul>
<li>创建分批发布<ul>
<li>分批发布信息</li>
<li>分批发布配置<ul>
<li>选择镜像</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以从已创建的阿里云镜像中选择镜像及版本</p>
<ul>
<li>服务暴露</li>
</ul>
<p><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594103703754-914cc08c-140e-460e-9499-9d78f23e7b87.png" alt="image.png"><br><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594103759355-12573398-e522-4342-ba4b-73dd9d097868.png" alt="image.png"></p>
<p><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594104093663-75fa1e5c-9fe8-4d82-a8b6-e5964f762fe8.png" alt="image.png"><br><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594105036671-8d9a5a71-d03e-4176-92e3-1df0fabc33dc.png" alt="image.png"><br><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594105106327-48f73739-c4e1-4ee2-8952-09160fe8be54.png" alt="image.png"></p>
<h3 id="发布更新"><a href="#发布更新" class="headerlink" title="发布更新"></a>发布更新</h3><p>已创建的服务，可以通过更新重新拉取新的镜像更新</p>
<ul>
<li>变更</li>
<li>第一次发布</li>
<li>发布完成</li>
</ul>
<p><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594105309826-f81f2e74-b4fa-40ca-a22a-37533cda613e.png" alt="image.png"></p>
<p><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594105422644-c6e5462a-da34-4599-a08d-4a60ee903618.png" alt="image.png"></p>
<h3 id="发布过程"><a href="#发布过程" class="headerlink" title="发布过程"></a>发布过程</h3><p>发布详情页面中会有发布进度，点击列表详情可以查看<br>开始发布时，如果有正在运行的pod,第一次发布则会首先更新重启其中一个pod，第一个pod发布完成之后，等待确认第二次发布，此时如果确认没有问题，则点击“继续”按钮进行第二次发布，则其他剩余pod继续更新重启。等待全部pod启动完成，点击“完成”按钮，服务更新完成，每次发布，pod应用版本+1。可通过应用版本判断pod是否是最新版本。<br><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594105556755-3e87cf13-ae9d-4947-8cc1-f55aa0598545.png" alt="image.png"><br><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594105629121-1adc593c-ff7f-4dee-b681-9663aad0f504.png" alt="image.png"></p>
<h3 id="服务访问方式"><a href="#服务访问方式" class="headerlink" title="服务访问方式"></a>服务访问方式</h3><h4 id="通过服务配置SLB访问"><a href="#通过服务配置SLB访问" class="headerlink" title="通过服务配置SLB访问"></a>通过服务配置SLB访问</h4><ul>
<li>应用列表中选择服务进入详情</li>
<li>选择访问tab 创建或更新对应service</li>
<li>可选择已有也可选择新建</li>
<li>注意选择关联</li>
</ul>
<p><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594106835192-be5ab629-037b-4290-8348-b3d1ff2ccd08.png" alt="image.png"></p>
<h4 id="通过路由配置策略访问"><a href="#通过路由配置策略访问" class="headerlink" title="通过路由配置策略访问"></a>通过路由配置策略访问</h4><ul>
<li>需要集群创建时安装ingress插件，且有公网访问权限</li>
</ul>
<p><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594106924764-c2244aee-54fc-46ec-8531-12d7b261e8c4.png" alt="image.png"></p>
<h3 id="水平伸缩"><a href="#水平伸缩" class="headerlink" title="水平伸缩"></a>水平伸缩</h3><ul>
<li>从应用列表中选择应用进入详情</li>
<li>点击进入容器组水平伸缩器tab</li>
<li>点击HPA创建按钮</li>
<li>点击指标“+”按钮添加指标，可选指标：CPU使用量、内存使用量</li>
</ul>
<p><img src="/2020/07/08/%E9%98%BF%E9%87%8C%E4%BA%91K8S%E6%89%98%E7%AE%A1%E7%89%88%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%83%A8%E7%BD%B2/1594107103670-6d462562-48b0-4c8f-863e-4d694830e96a.png" alt="image.png"></p>
<h3 id="尝试建议"><a href="#尝试建议" class="headerlink" title="尝试建议"></a>尝试建议</h3><p>如果有兴趣的小伙伴想要自己尝试一下，一些省钱的建议参考下</p>
<ul>
<li>ECS</li>
</ul>
<p>ECS可以选择抢占式按时按量付费 如 g6e 单台每小时大约0.3元</p>
<ul>
<li>负载均衡</li>
</ul>
<p>可以选择按量付费，通过阿里云控制台操作k8s时 走的是内网的负载均衡，流量费加上每小时收费每天差不多十块钱左右</p>
<ul>
<li>域名</li>
</ul>
<p>几十块钱三五年的可以考虑买一个，但是如果想要访问需要备案，阿里云会提供备案幕布<br>服务启动的时候可以把自己的域名解析到负载均衡的公网ip上 再通过路由对二级域名分发到不同的服务，方便访问</p>
]]></content>
      <categories>
        <category>工作</category>
        <category>运维</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署应用指南</title>
    <url>/2020/04/04/Docker%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="一、Docker的安装"><a href="#一、Docker的安装" class="headerlink" title="一、Docker的安装"></a>一、Docker的安装</h2><p>Docker的安装在不通操作系统下有不同的安装方式</p>
<a id="more"></a>

<h3 id="1-win7、win8安装docker"><a href="#1-win7、win8安装docker" class="headerlink" title="1.win7、win8安装docker"></a>1.win7、win8安装docker</h3><p>win7、win8 等需要利用 docker toolbox 来安装，国内可以使用阿里云的镜像来下载下载地址：<a href="http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/</a>  (没有安装git的则需勾选Git for Windows)</p>
<p><img src="/2020/04/04/Docker%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/1.png" alt></p>
<p>安装完成后桌面会有这三个程序</p>
<p><img src="/2020/04/04/Docker%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/2.png" alt></p>
<p>点击 Docker QuickStart 图标来启动 Docker Toolbox 终端，如果docker安装成功则会出现下图</p>
<p><img src="/2020/04/04/Docker%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/3.jpg" alt></p>
<p>（其中 【192.168.99.100】是VirtualBox中名字为【default】虚拟机的ip地址。）</p>
<h3 id="2-win10安装docker"><a href="#2-win10安装docker" class="headerlink" title="2.win10安装docker"></a>2.win10安装docker</h3><p>Docker for Windows分为企业版&gt;教育版&gt;专业版&gt;家庭版。（家庭版的不能开启Hyper-V，所以最低要专业版）</p>
<p>如果系统不符合运行Docker for Windows的要求，则可以安装Docker Toolbox，Dockbox Toolbox使用Oracle Virtual Box而不是Hyper-V。</p>
<p>在控制面板&gt;程序和功能&gt;打开或关闭Windows功能勾选Hyper-V </p>
<p>然后在CMD下运行此命令开启Hyper-V</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure>

<p>这样就可以下载安装包了，在docker官网下载Docker for Windows  <a href="https://www.docker.com/get-started" target="_blank" rel="noopener">https://www.docker.com/get-started</a></p>
<p>下载完进行安装启动，右下角会有小图标出现显示Docker Desktop is running  就说明docker启动好了。</p>
<p><img src="/2020/04/04/Docker%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/4.png" alt></p>
<h3 id="3-linux下安装docker"><a href="#3-linux下安装docker" class="headerlink" title="3.linux下安装docker"></a>3.linux下安装docker</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">* 安装依赖包</span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2 </span><br><span class="line"></span><br><span class="line">* 设置阿里云镜像源</span><br><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo </span><br><span class="line"></span><br><span class="line">* 安装 Docker-CE</span><br><span class="line">yum install docker-ce</span><br><span class="line"></span><br><span class="line">* 启动 Docker-CE</span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<h2 id="二、制作docker镜像"><a href="#二、制作docker镜像" class="headerlink" title="二、制作docker镜像"></a>二、制作docker镜像</h2><h3 id="1-通过dockerfile在本地制作镜像"><a href="#1-通过dockerfile在本地制作镜像" class="headerlink" title="1.通过dockerfile在本地制作镜像"></a>1.通过dockerfile在本地制作镜像</h3><p>  创建一个文件夹，里面放入打包好的war或者jar包，还需放入docekrfile文件，然后通过docker bulid命令来制作镜像</p>
<p>Dockerfile文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line"></span><br><span class="line">ADD blog-2.2.0.RELEASE.jar app.jar</span><br><span class="line"></span><br><span class="line">ADD application.yml &#x2F;</span><br><span class="line"></span><br><span class="line">RUN bash -c &#39;touch &#x2F;app.jar&#39;</span><br><span class="line"></span><br><span class="line">EXPOSE 8084</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ &quot;java&quot;, &quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;, &quot;-jar&quot;, &quot;&#x2F;app.jar&quot; ]</span><br></pre></td></tr></table></figure>

<p> 在dockerfile当前路径下输入命令 ：docker build -t [镜像名称] [本地路径] 命令来制作镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build –t mytest .</span><br></pre></td></tr></table></figure>

<h3 id="2-利用maven插件来进行制作镜像，并推送到远程仓库中（阿里云仓库）"><a href="#2-利用maven插件来进行制作镜像，并推送到远程仓库中（阿里云仓库）" class="headerlink" title="2.利用maven插件来进行制作镜像，并推送到远程仓库中（阿里云仓库）"></a>2.利用maven插件来进行制作镜像，并推送到远程仓库中（阿里云仓库）</h3><p>在项目的pom.xml中加入插件信息,再配置maven的setting.xml在servers节点下添加阿里云仓库的账号信息。</p>
<p>pom.xmlr如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--镜像名称--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">imageName</span>&gt;</span>$&#123;docker.repostory&#125;/$&#123;docker.registry.name&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--指定标签--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">imageTags</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">imageTag</span>&gt;</span>blog2<span class="tag">&lt;/<span class="name">imageTag</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">imageTags</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定Dockerfile所在的路径 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>./<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">serverId</span>&gt;</span>docker-aliyun<span class="tag">&lt;/<span class="name">serverId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">registryUrl</span>&gt;</span>$&#123;docker.repostory&#125;<span class="tag">&lt;/<span class="name">registryUrl</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">pushImage</span>&gt;</span>true<span class="tag">&lt;/<span class="name">pushImage</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>maven的setting.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--maven的pom中可以根据这个id找到这个server节点的配置--&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>docker-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--这里是在阿里云注册的账号--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--这里是在阿里云注册的密码--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这是在阿里云注册时填写的邮箱--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span>&gt;</span>xx@qq.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、镜像的拉取、导入、导出"><a href="#三、镜像的拉取、导入、导出" class="headerlink" title="三、镜像的拉取、导入、导出"></a>三、镜像的拉取、导入、导出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*镜像的拉取 &#x2F;&#x2F;默认在docker Hub中拉取镜像</span><br><span class="line">docker pull [镜像名称]:[镜像版本号]</span><br><span class="line"></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;kinggrid&#x2F;yypt:[镜像版本号] </span><br><span class="line"></span><br><span class="line">例：docker pull redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*镜像的导出</span><br><span class="line">docker save -o [.tar文件的名称] [镜像名称]  （导出镜像）</span><br><span class="line"></span><br><span class="line">例： docker save -o images.tar myblog </span><br><span class="line">（docker export -o images.tar myblog （导出容器））</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*镜像的导入</span><br><span class="line"></span><br><span class="line">docker load -i images.tar   导入镜像</span><br><span class="line">（docker import images.tar myblog （导出容器））</span><br></pre></td></tr></table></figure>

<h2 id="四、容器部署"><a href="#四、容器部署" class="headerlink" title="四、容器部署"></a>四、容器部署</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*容器部署</span><br><span class="line"></span><br><span class="line">docker run -d -p [宿主机的端口号]:[容器的端口号] -v [挂载的本地路径]:[容器内部路径] --name&#x3D;[命名容器的名称] [镜像名] </span><br><span class="line"> </span><br><span class="line">例：</span><br><span class="line">docker run -d -p 8084:8084 -v &quot;G:&#x2F;dockerfile&#x2F;application.yml&quot;:&#x2F;application.yml --name&#x3D;myblog myblog</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工作</category>
        <category>运维</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>项目启动脚本详解</title>
    <url>/2020/08/03/%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="一、脚本示例"><a href="#一、脚本示例" class="headerlink" title="一、脚本示例"></a>一、脚本示例</h4><p>首先我们拿一个简单的项目执行的脚本为例来进行详细的解析，示例脚本如下：</p>
<a id="more"></a>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/bash </span></span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">package_name="phoenix-api"</span><br><span class="line">processid=$(ps axo pid,cmd | grep "$&#123;package_name&#125;.jar" | grep -v grep | awk '&#123;print $1&#125;')</span><br><span class="line"></span><br><span class="line">function status() &#123;</span><br><span class="line">    processnum=$(ps axo pid,cmd | grep "$&#123;package_name&#125;.jar" | grep -v grep | wc -l)</span><br><span class="line">    if [ $&#123;processnum&#125; -eq 1 ]</span><br><span class="line">    then </span><br><span class="line">        echo "程序已运行,pid为$&#123;processid&#125;"</span><br><span class="line">    else </span><br><span class="line">	echo "程序未运行"</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function start() &#123;</span><br><span class="line">    processnum=$(ps axo pid,cmd | grep "$&#123;package_name&#125;.jar" | grep -v grep | wc -l)</span><br><span class="line">    if [ $&#123;processnum&#125; -eq 1 ]</span><br><span class="line">    then </span><br><span class="line">	echo "程序已运行,pid为$&#123;processid&#125;"</span><br><span class="line">	exit 1 </span><br><span class="line">    fi</span><br><span class="line">    #if [ -f $&#123;package_name&#125;.log ]</span><br><span class="line">    #then</span><br><span class="line">    #    mv $&#123;package_name&#125;.log $&#123;package_name&#125;.log_$(date +%y%m%d-%H%M)</span><br><span class="line">    #fi</span><br><span class="line">    nohup java -jar $&#123;package_name&#125;.jar --spring.profiles.active=dev --server.port=7214 &gt;&gt; $&#123;package_name&#125;.log 2&gt;&amp;1 &amp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function stop() &#123;</span><br><span class="line">    if [ -n "$&#123;processid&#125;" ]; then</span><br><span class="line">        kill $&#123;processid&#125;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function restart() &#123;</span><br><span class="line">    stop</span><br><span class="line">    sleep 5</span><br><span class="line">    start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">    status)</span><br><span class="line">	status</span><br><span class="line">	;;</span><br><span class="line">    start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        restart</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo 'server.sh (status|start|stop|restart)'</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<h4 id="二、详细解析"><a href="#二、详细解析" class="headerlink" title="二、详细解析"></a>二、详细解析</h4><p>除了第二行的<strong>#/bin/bash</strong> 为注明解析器，其余<strong>#</strong>都为注释</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">#/bin/bash 注明解析器</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">/bin/bash </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> sourcesource命令也称为“点命令”，也就是一个点符号（.）。<span class="built_in">source</span>命令通常用于重新执行刚修改的初始化文件，使之立即</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生效，而不必注销并重新登录。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /etc/profile ：这个文bai件是每个用户登录时都会运行du的环境变量设置，属于系统级别zhi的环境变量，设置在里面dao</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 的东西对所有用户适用</span></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义变量 package_name 值为 phoenix-api</span></span><br><span class="line">package_name="phoenix-api"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ps 查询进程装填；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> axo 为ps查询参数（查询条件）；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pid,cmd为显示的列，也就是只查询出pid和cmd两列； </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> | 为管道符号将前面的查询结果给到后面的输入到后面的查询；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> grep -v grep排除grep本身进程；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> awk 格式化文本信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">print</span> 输出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> $()表示执行（）里面的命令，一般考虑兼容性使用``</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$1</span> 为启动命令时后面接的参数，如 sh start.sh start,<span class="variable">$1</span>=start参数</span></span><br><span class="line">processid=$(ps axo pid,cmd | grep "$&#123;package_name&#125;.jar" | grep -v grep | awk '&#123;print $1&#125;')</span><br><span class="line"></span><br><span class="line">function status() &#123;</span><br><span class="line"><span class="meta">	#</span><span class="bash"> <span class="variable">$&#123;package_name&#125;</span>，应用之前定义的package_name变量</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> wc -l 统计行数</span></span><br><span class="line">    processnum=$(ps axo pid,cmd | grep "$&#123;package_name&#125;.jar" | grep -v grep | wc -l)</span><br><span class="line">    # [] 等同于test,用于计算</span><br><span class="line">    # -eq 比较两个变量是否相等</span><br><span class="line">    if [ $&#123;processnum&#125; -eq 1 ]</span><br><span class="line">    # then满足条件执行</span><br><span class="line">    then </span><br><span class="line">   		# echo 输出命令</span><br><span class="line">        echo "程序已运行,pid为$&#123;processid&#125;"</span><br><span class="line">    else </span><br><span class="line">	echo "程序未运行"</span><br><span class="line"><span class="meta">	#</span><span class="bash"> <span class="keyword">fi</span>为<span class="keyword">if</span>倒过来，表示<span class="keyword">if</span>判断结束</span></span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function start() &#123;</span><br><span class="line">    processnum=$(ps axo pid,cmd | grep "$&#123;package_name&#125;.jar" | grep -v grep | wc -l)</span><br><span class="line">    if [ $&#123;processnum&#125; -eq 1 ]</span><br><span class="line">    then </span><br><span class="line">	echo "程序已运行,pid为$&#123;processid&#125;"</span><br><span class="line"><span class="meta">	#</span><span class="bash"> <span class="built_in">exit</span>退出命令窗口</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> <span class="built_in">exit</span> 1 非正常运行导致退出程序,<span class="built_in">exit</span> 0表示正常运行程序并退出程序</span></span><br><span class="line">	exit 1 </span><br><span class="line">    fi</span><br><span class="line">    # nohup 表示不挂断地运行命令，一般与&amp;（写在命令最后）配合，不挂断且可以在后台一直运行</span><br><span class="line">    # java -jar xxx.jar 表示运行这个xxx.jar包</span><br><span class="line">    # --spring.profiles.active=dev 配置有效的配置文件，这里指作用的配置文件为dev</span><br><span class="line">    # --server.port=7214 配置有效的端口，这里指有效端口为7214</span><br><span class="line">    # &gt;&gt; 重定向追加到某文件，可以理解为追加输出到某文件里</span><br><span class="line">    # 2&gt;&amp;1 一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</span><br><span class="line">    #    标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</span><br><span class="line">    #    标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</span><br><span class="line">    #	 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</span><br><span class="line">    # 所以2&gt;&amp;1 的意思为：将 stdout 和 stderr 合并后重定向到文件</span><br><span class="line">    nohup java -jar $&#123;package_name&#125;.jar --spring.profiles.active=dev --server.port=7214 &gt;&gt; $&#123;package_name&#125;.log 2&gt;&amp;1 &amp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function stop() &#123;</span><br><span class="line"><span class="meta"> 	#</span><span class="bash"> -n 来判定字符串非空。</span></span><br><span class="line">    if [ -n "$&#123;processid&#125;" ]; then</span><br><span class="line">    	# kill 杀掉某个进程</span><br><span class="line">        kill $&#123;processid&#125;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function restart() &#123;</span><br><span class="line">    stop</span><br><span class="line">    # sleep 睡眠，5代表5秒</span><br><span class="line">    sleep 5</span><br><span class="line">    start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span>多模式匹配选择</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$1</span> 为启动命令时后面接的参数，如 sh start.sh start,<span class="variable">$1</span>=start参数,与后面的模式进行匹配</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> xxx)代表一种模式，与<span class="keyword">case</span>后面的参数相匹配，如：start)</span></span><br><span class="line">case $1 in</span><br><span class="line">    status)</span><br><span class="line">    # 调用上面定义的status方法</span><br><span class="line">	status</span><br><span class="line"><span class="meta">	#</span><span class="bash"> ;;表示该模式执行完毕</span></span><br><span class="line">	;;</span><br><span class="line">    start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        restart</span><br><span class="line">        ;;</span><br><span class="line">    # *）表示如果上面的模式都不匹配，则进行这个模式中</span><br><span class="line">    *)</span><br><span class="line">        echo 'server.sh (status|start|stop|restart)'</span><br><span class="line">        ;;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">esac</span>为<span class="keyword">case</span>反写表示多模式匹配选择结束</span></span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工作</category>
        <category>运维</category>
        <category>shell命令</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式详解</title>
    <url>/2020/07/10/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>  工厂方法模式（Fatory Method Pattern）是指定义一个创建对象的接口，但让实现这个 接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。属于创建型模式，23中设计模式之一，在工厂方法 模式中用户只需要关心所需产品对应的工厂，无须关心创建细节，而且加入新的产品符 合开闭原则。</p>
<a id="more"></a>

<p>  工厂方法模式其实就是简单工厂模式的一个拓展，只是将工厂接口化，具体的实现让实现类决定。</p>
<h4 id="二、代码实现（示例）"><a href="#二、代码实现（示例）" class="headerlink" title="二、代码实现（示例）"></a>二、代码实现（示例）</h4><p>1、示例背景：一个时间管理者拥有多个女朋友，那么他要记住每个女朋友的名字，每天晚上根据名字去微信找到她们，给她们每个人发晚安，或者叫她们来侍寝。</p>
<p>2、创建每个对象需要做的事</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CreateObject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createObject</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3、首先创建两个女朋友</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReBa</span> <span class="keyword">implements</span> <span class="title">CreateObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是迪丽热巴，我来啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NaZha</span> <span class="keyword">implements</span> <span class="title">CreateObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是古力娜扎，我来啦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>4、创建一个工厂，用来实例化对象，注意这里就是和简单工厂模式不同的地方，这里的工厂是个接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Interface Factory&#123;</span><br><span class="line">    CreateObject create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>4、创建一个实例工厂，具体实例化的对象（要找的女朋友）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CreateObject <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReBa();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>5、写个测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestFactory testFactory = <span class="keyword">new</span> TestFactory();</span><br><span class="line">        testFactory.create().createObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>6、测试结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是迪丽热巴，我来啦</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工作</category>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>静态代理模式详解</title>
    <url>/2020/07/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>1、以一个生活中的例子来解释静态代理模式：到了一定的年龄，我们就要结婚，结婚是一件很麻烦的事情，（包括那些被父母催婚的）。有钱的家庭可能会找司仪来主持婚礼，显得热闹，洋气～好了，现在婚庆公司的生意来了，我们只需要给钱，婚庆公司就会帮我们安排一整套结婚的流程。整个流程大概是这样的：家里人催婚-&gt;男女双方家庭商定结婚的黄道即日-&gt;找一家靠谱的婚庆公司-&gt;在约定的时间举行结婚仪式-&gt;结婚完毕。婚庆公司打算怎么安排婚礼的节目，在婚礼完毕以后婚庆公司会做什么，我们一概不知，我们只要把钱给人家，人家会把事情给我们做好。所以，这里的婚庆公司相当于代理角色。例子代码主要如下：</p>
<a id="more"></a>

<p>2、创建一个代理结婚的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代理接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyInterface</span> </span>&#123;</span><br><span class="line"><span class="comment">//需要代理的是结婚这件事，如果还有其他事情需要代理，比如吃饭睡觉上厕所，也可以写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">marry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3、定义婚庆公司需要做的工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">ProxyInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ProxyInterface proxyInterface;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(ProxyInterface proxyInterface)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.proxyInterface = proxyInterface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"我们是婚庆公司的"</span>);</span><br><span class="line"> System.out.println(<span class="string">"我们在做结婚前的准备工作"</span>);</span><br><span class="line"> System.out.println(<span class="string">"节目彩排..."</span>);</span><br><span class="line"> System.out.println(<span class="string">"礼物购买..."</span>);</span><br><span class="line"> System.out.println(<span class="string">"工作人员分工..."</span>);</span><br><span class="line"> System.out.println(<span class="string">"可以开始结婚了"</span>);</span><br><span class="line"> proxyInterface.marry();</span><br><span class="line"> System.out.println(<span class="string">"结婚完毕，我们需要做后续处理，你们可以回家了，其余的事情我们公司来做"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>4、新人只需要结婚就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalHome</span> <span class="keyword">implements</span> <span class="title">ProxyInterface</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"我们结婚啦～"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>5、创建一个测试类，看看结婚的流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> ProxyInterface proxyInterface = <span class="keyword">new</span> WeddingCompany(<span class="keyword">new</span> NormalHome());</span><br><span class="line"> proxyInterface.marry();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<p><img src="/2020/07/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/1750305-20190727163806698-639979178.png" alt="img"></p>
]]></content>
      <categories>
        <category>工作</category>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试无法修改数据库数据</title>
    <url>/2020/07/08/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%97%A0%E6%B3%95%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>1、在@Test中无法进行数据库信息修改的原因：</p>
<p>​    spring boot 集成data jpa 在test区测试数据库操作的时候，查询正常，但是其他对数据库更改却不能成功，例如存入数据库，会报read-only，这时候需要添加@transactional注解，终于不报错了，但是在存入一次后，却发现数据库并没有数</p>
<a id="more"></a>

<p>据。再查看log时候发现，事务竟然回滚了，没错，查询资料，原来spring boot测试单元为了默认会事务回滚，这时候需要添加强制不回滚注解，@rollbask(false)，其中上面两个注解是为了让测试运行spring环境，也就是当前项目配置。</p>
<p>所以想要在单元测试中修改数据库中信息需要加上两个注解：@Transactional和@Rollbask(false)。</p>
]]></content>
      <categories>
        <category>工作</category>
        <category>java</category>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>索引</title>
    <url>/2020/07/08/%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>MySQL目前主要有以下几种索引类型：<br>1.普通索引<br>2.唯一索引<br>3.主键索引<br>4.组合索引<br>5.全文索引</p>
<a id="more"></a>

<h3 id="二、语句"><a href="#二、语句" class="headerlink" title="二、语句"></a>二、语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name[col_name data type]</span><br><span class="line">[unique|fulltext][index|key][index_name](col_name[length])[asc|desc]</span><br></pre></td></tr></table></figure>

<p>1.unique|fulltext为可选参数，分别表示唯一索引、全文索引<br>2.index和key为同义词，两者作用相同，用来指定创建索引<br>3.col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择<br>4.index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值<br>5.length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度<br>6.asc或desc指定升序或降序的索引值存储</p>
<h3 id="三、索引类型"><a href="#三、索引类型" class="headerlink" title="三、索引类型"></a>三、索引类型</h3><p>1.普通索引<br>是最基本的索引，它没有任何限制。它有以下几种创建方式：<br>（1）直接创建索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CREATE INDEX index_name ON <span class="title">table</span><span class="params">(column(length)</span>)</span></span><br></pre></td></tr></table></figure>

<p>（2）修改表结构的方式添加索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ALTER TABLE table_name ADD INDEX index_name <span class="title">ON</span> <span class="params">(column(length)</span>)</span></span><br></pre></td></tr></table></figure>

<p>（3）创建表的时候同时创建索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` <span class="keyword">int</span>(<span class="number">11</span>) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` <span class="keyword">char</span>(<span class="number">255</span>) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` <span class="keyword">int</span>(<span class="number">10</span>) NULL DEFAULT NULL ,</span><br><span class="line">    <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`id`)</span>,</span></span><br><span class="line"><span class="function">    INDEX <span class="title">index_name</span> <span class="params">(title(length)</span>)</span></span><br><span class="line"><span class="function">)</span></span><br></pre></td></tr></table></figure>

<p>（4）删除索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure>



<p>2.唯一索引<br>    与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：<br>（1）创建唯一索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON table(column(length))</span><br></pre></td></tr></table></figure>

<p>（2）修改表结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))</span><br></pre></td></tr></table></figure>

<p>（3）创建表的时候直接指定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;table&#96; (</span><br><span class="line">    &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    &#96;title&#96; char(255) CHARACTER NOT NULL ,</span><br><span class="line">    &#96;content&#96; text CHARACTER NULL ,</span><br><span class="line">    &#96;time&#96; int(10) NULL DEFAULT NULL ,</span><br><span class="line">    UNIQUE indexName (title(length))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>3.主键索引<br>是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;table&#96; (</span><br><span class="line">    &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    &#96;title&#96; char(255) NOT NULL ,</span><br><span class="line">    PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>4.组合索引<br>    指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#96;table&#96; ADD INDEX name_city_age (name,city,age);</span><br></pre></td></tr></table></figure>

<p>5.全文索引<br>    主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。<br>（1）创建表的适合添加全文索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;table&#96; (</span><br><span class="line">    &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    &#96;title&#96; char(255) CHARACTER NOT NULL ,</span><br><span class="line">    &#96;content&#96; text CHARACTER NULL ,</span><br><span class="line">    &#96;time&#96; int(10) NULL DEFAULT NULL ,</span><br><span class="line">    PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">    FULLTEXT (content)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>（2）修改表结构添加全文索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE article ADD FULLTEXT index_content(content)</span><br></pre></td></tr></table></figure>

<p>（3）直接创建索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE FULLTEXT INDEX index_content ON article(content)</span><br></pre></td></tr></table></figure>



<h3 id="四、缺点"><a href="#四、缺点" class="headerlink" title="四、缺点"></a>四、缺点</h3><p>1.虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行insert、update和delete。因为更新表时，不仅要保存数据，还要保存一下索引文件。<br>2.建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会增长很快。<br>索引只是提高效率的一个因素，如果有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。</p>
<h3 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h3><p>使用索引时，有以下一些技巧和注意事项：<br>1.索引不会包含有null值的列<br>只要列中包含有null值都将不会被包含在索引中，复合索引中只要有一列含有null值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为null。<br>2.使用短索引<br>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个char(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。<br>3.索引列排序<br>查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。<br>4.like语句操作<br>一般情况下不推荐使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。<br>5.不要在列上进行运算<br>这将导致索引失效而进行全表扫描，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE YEAR(column_name)&lt;2017;</span><br></pre></td></tr></table></figure>

<p>6.不使用not in和&lt;&gt;操作</p>
]]></content>
      <categories>
        <category>工作</category>
        <category>java</category>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>随机生成时间戳</title>
    <url>/2020/07/08/%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E6%97%B6%E9%97%B4%E6%88%B3/</url>
    <content><![CDATA[<p>1、在指定的范围内随机生成时间戳：</p>
<p>​    需要将随机数缩放到特定年份的范围内,并将年份的开头作为偏移量.一年中的毫秒数从一年变为另一年(闰年有额外的一天,某些年份有飞跃时间等),因此您可以按比例确定缩放之前的范围：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> offset = Timestamp.valueOf(<span class="string">"2019-01-01 00:00:00"</span>).getTime();</span><br><span class="line"><span class="keyword">long</span> end = Timestamp.valueOf(<span class="string">"2020-01-01 00:00:00"</span>).getTime();</span><br><span class="line"><span class="keyword">long</span> diff = end - offset + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//在指定范围内随机生成时间戳</span></span><br><span class="line">Timestamp rand = <span class="keyword">new</span> Timestamp(offset + (<span class="keyword">long</span>)(Math.random() * diff));</span><br><span class="line"><span class="comment">//时间戳转Long类型</span></span><br><span class="line"><span class="keyword">long</span> time = rand.getTime();</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>工作</category>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>多态详解</title>
    <url>/2020/07/08/%E5%A4%9A%E6%80%81%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>java多态的三个必要条件：</p>
<p>（1） 继承。</p>
<p>（2） 子类重写父类方法。</p>
<p>（3） 父类引用指向子类对象。</p>
<a id="more"></a>

<p><img src="/2020/07/08/%E5%A4%9A%E6%80%81%E8%AF%A6%E8%A7%A3/1f8c000507d84f7ec409" alt="从JVM角度看Java多态"></p>
<p><img src="/2020/07/08/%E5%A4%9A%E6%80%81%E8%AF%A6%E8%A7%A3/1f8c000508087a4f1f5d" alt="从JVM角度看Java多态"></p>
<p>输出结果为：</p>
<p><img src="/2020/07/08/%E5%A4%9A%E6%80%81%E8%AF%A6%E8%A7%A3/212e0001335c015dff2c" alt="从JVM角度看Java多态"></p>
<p>  给出结论：Father  c  =  new  Child()   在c的眼里只能看到 child 里面的 father 属性！当满Java多态的三个条件时，可以发现c.eat()调用的实际上是子类的eat（是因为子类重写覆盖了父类方法），但c.age调用的还是父类的age（*<em>属性/变量不存在重写和覆盖*</em>），而c.play()则不会通过编译。</p>
]]></content>
      <categories>
        <category>工作</category>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>打开共享文件夹</title>
    <url>/2020/07/08/%E6%89%93%E5%BC%80%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<p>1、Win+R打开cmd命令输入框</p>
<p><img src="/2020/07/08/%E6%89%93%E5%BC%80%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/image-20200701095640226-1594219201180.png" alt="image-20200701095640226"></p>
<a id="more"></a>

<p>2、输入共享文件地址如上图</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>电脑操作</category>
      </categories>
      <tags>
        <tag>电脑操作</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰者模式详解</title>
    <url>/2020/07/08/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>1、装饰者模式的作用：</p>
<p>  对已有的业务逻辑进一步的封装，使其增加额外的功能，如Java中的IO流就使用了装饰者模式，用户在使用的时候，可以任意组装，达到自己想要的效果。</p>
<p>  举个栗子，我想吃三明治，首先我需要一根大大的香肠，我喜欢吃奶油，在香肠上面加一点奶油，再放一点蔬菜，最后再用两片面包夹一下，很丰盛的一顿午饭，营养又健康。（ps：不知道上海哪里有卖好吃的三明治的，求推荐～）那我们应该怎么来写代码呢？ 首先，我们需要写一个Food类，让其他所有食物都来继承这个类。</p>
<a id="more"></a>

<p>2、代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String food_name;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Food</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Food</span><span class="params">(String food_name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.food_name = food_name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> food_name;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写几个子类继承父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//面包类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bread</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Food basic_food;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Bread</span><span class="params">(Food basic_food)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.basic_food = basic_food;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> basic_food.make()+<span class="string">"+面包"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//奶油类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cream</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Food basic_food;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Cream</span><span class="params">(Food basic_food)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.basic_food = basic_food;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> basic_food.make()+<span class="string">"+奶油"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//蔬菜类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vegetable</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Food basic_food;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Vegetable</span><span class="params">(Food basic_food)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.basic_food = basic_food;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> basic_food.make()+<span class="string">"+蔬菜"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几个类都是差不多的，构造方法传入一个Food类型的参数，然后在make方法中加入一些自己的逻辑,写个测试类进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Food food = <span class="keyword">new</span> Bread(<span class="keyword">new</span> Vegetable(<span class="keyword">new</span> Cream(<span class="keyword">new</span> Food(<span class="string">"香肠"</span>))));</span><br><span class="line">       System.out.println(food.make());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2020/07/08/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/1750305-20190727163511568-1035310008.png" alt="img"></p>
]]></content>
      <categories>
        <category>工作</category>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式详解</title>
    <url>/2020/07/08/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>1、适配器模式的作用：</p>
<p>  将两种完全不同的事物联系到一起，就像现实生活中的变压器。假设一个手机充电器需要的电压是20V，但是正常的电压是220V，这时候就需要一个变压器，将220V的电压转换成20V的电压，这样，变压器就将20V的电压和手机联系起来了。</p>
<a id="more"></a>

<p>2、代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">       VoltageAdapter adapter = <span class="keyword">new</span> VoltageAdapter();</span><br><span class="line">       phone.setAdapter(adapter);</span><br><span class="line">       phone.charge();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> V = <span class="number">220</span>;<span class="comment">// 正常电压220v，是一个常量</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> VoltageAdapter adapter;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 充电</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       adapter.changeVoltage();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(VoltageAdapter adapter)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.adapter = adapter;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变压器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 改变电压的功能</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeVoltage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"正在充电..."</span>);</span><br><span class="line">       System.out.println(<span class="string">"原始电压："</span> + Phone.V + <span class="string">"V"</span>);</span><br><span class="line">       System.out.println(<span class="string">"经过变压器转换之后的电压:"</span> + (Phone.V - <span class="number">200</span>) + <span class="string">"V"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工作</category>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式详解</title>
    <url>/2020/07/08/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>1、模式动机及定义：</p>
<p>  建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。</p>
<a id="more"></a>

<p>  观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p>
<p>2、模式分析：</p>
<p>  观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。<br>  这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。<br>  作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为发布-订阅(publishsubscribe)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。</p>
<p>3、优缺点比较：</p>
<p>优点：</p>
<ul>
<li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li>
<li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li>
<li>观察者模式支持广播通信。</li>
<li>观察者模式符合“开闭原则”的要求。</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ul>
<p>4、使用环境</p>
<p>  观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</p>
<p>5、具体实现：</p>
<p>第一种解释：</p>
<p>主题类也是被观察类（NewsPaperOfficeJava）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsPaperOfficeJava</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> time = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        message = <span class="string">"第"</span>+time +<span class="string">"次发的新闻"</span>;</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers();</span><br><span class="line">        time++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察者的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstObserverJava</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;<span class="comment">//JAVA观察者实现</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    Observable mObservable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        mObservable = o;</span><br><span class="line">        <span class="keyword">if</span>(mObservable <span class="keyword">instanceof</span> NewsPaperOfficeJava)&#123;</span><br><span class="line">            message = <span class="string">"FirstObserver 收到了"</span> + ((NewsPaperOfficeJava) mObservable).getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第二种解释：</p>
<p>  举个栗子：假设有三个人，小美（女，22），小王和小李。小美很漂亮，小王和小李是两个程序猿，时刻关注着小美的一举一动。有一天，小美说了一句：“谁来陪我打游戏啊。”这句话被小王和小李听到了，结果乐坏了，蹭蹭蹭，没一会儿，小王就冲到小美家门口了，在这里，小美是被观察者，小王和小李是观察者，被观察者发出一条信息，然后观察者们进行相应的处理，看代码：</p>
<p>发送消息接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="comment">//小王和小李通过这个接口可以接收到小美发过来的消息</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">getMessage</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这个接口相当于小王和小李的电话号码，小美发送通知的时候就会拨打getMessage这个电话，拨打电话就是调用接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LaoWang</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name = <span class="string">"小王"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LaoWang</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       System.out.println(name + <span class="string">"接到了小美打过来的电话，电话内容是："</span> + s);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LaoLi</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name = <span class="string">"小李"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LaoLi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       System.out.println(name + <span class="string">"接到了小美打过来的电话，电话内容是：-&gt;"</span> + s);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，我们再看看小美的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMei</span> </span>&#123;</span><br><span class="line">   List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XiaoMei</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        list.add(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历list，把自己的通知发送给所有暗恋自己的人</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Person person:list)&#123;</span><br><span class="line">            person.getMessage(<span class="string">"你们过来吧，谁先过来谁就能陪我一起玩儿游戏!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       XiaoMei xiao_mei = <span class="keyword">new</span> XiaoMei();</span><br><span class="line">       LaoWang lao_wang = <span class="keyword">new</span> LaoWang();</span><br><span class="line">       LaoLi lao_li = <span class="keyword">new</span> LaoLi();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//小王和小李在小美那里都注册了一下</span></span><br><span class="line">       xiao_mei.addPerson(lao_wang);</span><br><span class="line">       xiao_mei.addPerson(lao_li);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//小美向小王和小李发送通知</span></span><br><span class="line">       xiao_mei.notifyPerson();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工作</category>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式详解</title>
    <url>/2020/07/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>1、单例模式的介绍：<br>  单例模式（Singleton），也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 </p>
<a id="more"></a>

<p>2、实现单例模式的思路是：<br>  一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名 称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们 还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p>
<p>3、单例模式需要注意的地方：<br>  单例模式在多线程的 应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例， 这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。 </p>
<p>4以下都是单例模式的经典使用场景：<br>  （1）资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。<br>  （2）控制资源的情况下，方便资源之间的互相通信。如线程池等。 </p>
<p>5、应用场景举例：<br> （1）外部资源：每台计算机有若干个打印机，但只能有一个PrinterSpooler，以避免两个打印作业同时输出到打印机。内部资源：大多数软件都有一个（或多个）属性文件存放系统配置，这样的系统应该有一个对象管理这些属性文件<br>  （2）Windows的Task Manager（任务管理器）就是很典型的单例模式（这个很熟悉吧），想想看，是不是呢，你能打开两个windows task manager吗？ 不信你自己试试看哦~<br>  （3）windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。<br>  （4）网站的计数器，一般也是采用单例模式实现，否则难以同步。<br>  （5）应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。<br>  （6）Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。<br>  （7）数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。<br>  （8）多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。<br>  （9）操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。<br>  （10）HttpApplication 也是单位例的典型应用。熟悉ASP.Net(IIS)的整个请求生命周期的人应该知道HttpApplication也是单例模式，所有的HttpModule都共享一个HttpApplication实例. </p>
<p>6、实现单利模式的原则和过程：<br>  （1）单例模式：确保一个类只有一个实例，自行实例化并向系统提供这个实例<br>  （2）单例模式分类：饿单例模式（类加载时实例化一个对象给自己的引用），懒单例模式（调用取得实例的方法如getInstance时才会实例化对象）（java中饿单例模式性能优于懒单例模式，c++中一般使用懒单例模式）<br>  （3）单例模式要素：<br>    a.私有构造方法<br>    b.私有静态引用指向自己实例<br>    c.以自己实例为返回值的公有静态方法 </p>
<p>7、实现的方式：</p>
<p>（1）饿汉式：单例实例在类装载时就构建，急切初始化(预先加载法）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Test instance = <span class="keyword">new</span> Test();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Test <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点 :<br>  1)线程安全<br>  2)在类加载的同时已经创建好一个静态对象，调用时反应速度快<br>缺点 :<br>  资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化 </p>
<p>(2)懒汉式：单例实例在第一次被使用时构建，延迟初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//多个线程判断instance都为null时，在执行new操作时多线程会出现重复情况</span></span><br><span class="line">            instance = <span class="keyword">new</span> Test();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>优点：<br>  避免了饿汉式的那种在没有用到的情况下创建事例，资源利用率高，不执行getInstance()就不会被实例，可以执行该类的其他静态方法。<br>缺点：<br>  懒汉式在单个线程中没有问题，但多个线程同事访问的时候就可能同事创建多个实例，而且这多个实例不是同一个对象，虽然后面创建的实例会覆盖先创建的实例，但是还是会存在拿到不同对象的情况。解决这个问题的办法就是加锁synchonized，第一次加载时不够快，多线程使用不必要的同步开销大。 </p>
<p>(3)双重检测 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">static</span> Test instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            	<span class="keyword">synchronized</span> (Test<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        instance = <span class="keyword">new</span> Test();</span><br><span class="line">                    &#125;</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>优点 ：<br>  资源利用率高，不执行getInstance()就不被实例，可以执行该类其他静态方法 。<br>缺点 ：<br>  第一次加载时反应不快，由于java内存模型一些原因偶尔失败 。</p>
<p>（4）静态内部类 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHelp</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> Test instance = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> SingletonHelp.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点 ：<br>  资源利用率高，不执行getInstance()不被实例，可以执行该类其他静态方法<br>缺点 ：<br>  第一次加载时反应不够快 </p>
<p>8、总结：<br>  一般采用饿汉式，若对资源十分在意可以采用静态内部类，不建议采用懒汉式及双重检测</p>
]]></content>
      <categories>
        <category>工作</category>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo命令</title>
    <url>/2020/07/08/Hexo%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>1、创建文章</p>
<p>  进入hexo目录下的_post目录,如D:\Hexo\Blog\source_posts。输入命令hexo new “文章标题”。在这个目录下则会出现这个文件并包含储存对应文章图片的文件夹。</p>
<a id="more"></a>

<p>2、清除缓存文件 db.json 和已生成的静态文件 public </p>
<p> 进入hexo目录下的_post目录,如D:\Hexo\Blog\source_posts。输入命令hexo clean。</p>
<p>3、生成网站静态文件到默认设置的 public 文件夹</p>
<p>进入hexo目录下的_post目录,如D:\Hexo\Blog\source_posts。输入命令hexo  g。</p>
<p>4、自动生成网站静态文件，并部署到设定的仓库</p>
<p>进入hexo目录下的_post目录,如D:\Hexo\Blog\source_posts。输入命令hexo  d。</p>
<p>总结：一般文档写完之后，直接连续使用 hexo clean、hexo  g和hexo  d进行发布。</p>
]]></content>
      <categories>
        <category>工作</category>
        <category>开发工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>开发工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>导出项目javadoc文档</title>
    <url>/2020/07/08/%E5%AF%BC%E5%87%BA%E9%A1%B9%E7%9B%AEjavadoc%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>1、找到idea中的Tools，导航栏，选择Generate JavaDoc选项，如图：</p>
<a id="more"></a>

<p><img src="/2020/07/08/%E5%AF%BC%E5%87%BA%E9%A1%B9%E7%9B%AEjavadoc%E6%96%87%E6%A1%A3/image-20200630134419074.png" alt></p>
<p>2、选择输出文档的地址，并选择输出文档的编码格式：</p>
<p><img src="/2020/07/08/%E5%AF%BC%E5%87%BA%E9%A1%B9%E7%9B%AEjavadoc%E6%96%87%E6%A1%A3/image-20200630134555245.png" alt></p>
]]></content>
      <categories>
        <category>工作</category>
        <category>开发工具</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>开发工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>使用map实现本地缓存</title>
    <url>/2020/07/08/%E4%BD%BF%E7%94%A8map%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h4 id="一、创建定时器线程池"><a href="#一、创建定时器线程池" class="headerlink" title="一、创建定时器线程池"></a>一、创建定时器线程池</h4>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryClass</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(r, <span class="string">"SegmentScheduledExecutorThread"</span>);</span><br><span class="line">            t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService ScheduledService = Executors.newSingleThreadScheduledExecutor(<span class="keyword">new</span> FactoryClass());</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="二、创建map-并实现put和get方法"><a href="#二、创建map-并实现put和get方法" class="headerlink" title="二、创建map,并实现put和get方法"></a>二、创建map,并实现put和get方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, Entity&gt; MAP = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data   值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expire 过期时间，单位：毫秒， 0表示无限长</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object data, <span class="keyword">long</span> expire)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//清除原键值对</span></span><br><span class="line">       CacheUtils.remove(key);</span><br><span class="line">       <span class="comment">//设置过期时间</span></span><br><span class="line">       <span class="keyword">if</span> (expire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           Future future = ScheduledService.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="comment">//过期后清除该键值对</span></span><br><span class="line">                   <span class="keyword">synchronized</span> (CacheUtils<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                       MAP.remove(key);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, expire, TimeUnit.MILLISECONDS);</span><br><span class="line">           MAP.put(key, <span class="keyword">new</span> Entity(data, future));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//不设置过期时间</span></span><br><span class="line">           MAP.put(key, <span class="keyword">new</span> Entity(data, <span class="keyword">null</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 读取缓存</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">       Entity entity = MAP.get(key);</span><br><span class="line">       <span class="keyword">return</span> entity == <span class="keyword">null</span> ? <span class="keyword">null</span> : (T) entity.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="三、创建remove方法，移除过期的键值对"><a href="#三、创建remove方法，移除过期的键值对" class="headerlink" title="三、创建remove方法，移除过期的键值对"></a>三、创建remove方法，移除过期的键值对</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 清除缓存</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//清除原缓存数据</span></span><br><span class="line">     Entity entity = MAP.remove(key);</span><br><span class="line">     <span class="keyword">if</span> (entity == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//清除原键值对定时器</span></span><br><span class="line">     <span class="keyword">if</span> (entity.future != <span class="keyword">null</span>) &#123;</span><br><span class="line">         entity.future.cancel(<span class="keyword">true</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> (T) entity.value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h4 id="四、使用到的内部实体类"><a href="#四、使用到的内部实体类" class="headerlink" title="四、使用到的内部实体类"></a>四、使用到的内部实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 缓存实体类</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 键值对的value</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">public</span> Object value;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 定时器Future</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">public</span> Future future;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Entity</span><span class="params">(Object value, Future future)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.value = value;</span><br><span class="line">         <span class="keyword">this</span>.future = future;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工作</category>
        <category>java</category>
        <category>缓存</category>
        <category>代码备忘录</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
</search>
